// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef PROTOBUF_client_2eproto__INCLUDED
#define PROTOBUF_client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace connector_client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eproto();
void protobuf_AssignDesc_client_2eproto();
void protobuf_ShutdownFile_client_2eproto();

class CSHead;
class CSSyn;
class CSSynAck;
class CSAuth;
class CSPassport;
class CSStart;
class CSError;
class CSBody;
class CSMsg;

enum ConnectorMagic {
  MAGIC_CS_V1 = 13124
};
bool ConnectorMagic_IsValid(int value);
const ConnectorMagic ConnectorMagic_MIN = MAGIC_CS_V1;
const ConnectorMagic ConnectorMagic_MAX = MAGIC_CS_V1;
const int ConnectorMagic_ARRAYSIZE = ConnectorMagic_MAX + 1;

const ::google_public::protobuf::EnumDescriptor* ConnectorMagic_descriptor();
inline const ::std::string& ConnectorMagic_Name(ConnectorMagic value) {
  return ::google_public::protobuf::internal::NameOfEnum(
    ConnectorMagic_descriptor(), value);
}
inline bool ConnectorMagic_Parse(
    const ::std::string& name, ConnectorMagic* value) {
  return ::google_public::protobuf::internal::ParseNamedEnum<ConnectorMagic>(
    ConnectorMagic_descriptor(), name, value);
}
enum BodyCmdId {
  SYN = 1,
  SYNACK = 2,
  AUTHENTICATION = 3,
  PASSPORT = 4,
  START_APP = 5,
  DATA_TRANSPARENT = 16,
  ERROR = 100
};
bool BodyCmdId_IsValid(int value);
const BodyCmdId BodyCmdId_MIN = SYN;
const BodyCmdId BodyCmdId_MAX = ERROR;
const int BodyCmdId_ARRAYSIZE = BodyCmdId_MAX + 1;

const ::google_public::protobuf::EnumDescriptor* BodyCmdId_descriptor();
inline const ::std::string& BodyCmdId_Name(BodyCmdId value) {
  return ::google_public::protobuf::internal::NameOfEnum(
    BodyCmdId_descriptor(), value);
}
inline bool BodyCmdId_Parse(
    const ::std::string& name, BodyCmdId* value) {
  return ::google_public::protobuf::internal::ParseNamedEnum<BodyCmdId>(
    BodyCmdId_descriptor(), name, value);
}
// ===================================================================

class CSHead : public ::google_public::protobuf::Message {
 public:
  CSHead();
  virtual ~CSHead();

  CSHead(const CSHead& from);

  inline CSHead& operator=(const CSHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSHead& default_instance();

  void Swap(CSHead* other);

  // implements Message ----------------------------------------------

  CSHead* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSHead& from);
  void MergeFrom(const CSHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 magic = 1 [default = 13124];
  inline bool has_magic() const;
  inline void clear_magic();
  static const int kMagicFieldNumber = 1;
  inline ::google_public::protobuf::int32 magic() const;
  inline void set_magic(::google_public::protobuf::int32 value);

  // required int64 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google_public::protobuf::int64 sequence() const;
  inline void set_sequence(::google_public::protobuf::int64 value);

  // required int32 bodyid = 3;
  inline bool has_bodyid() const;
  inline void clear_bodyid();
  static const int kBodyidFieldNumber = 3;
  inline ::google_public::protobuf::int32 bodyid() const;
  inline void set_bodyid(::google_public::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:connector_client.CSHead)
 private:
  inline void set_has_magic();
  inline void clear_has_magic();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_bodyid();
  inline void clear_has_bodyid();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_public::protobuf::int64 sequence_;
  ::google_public::protobuf::int32 magic_;
  ::google_public::protobuf::int32 bodyid_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSHead* default_instance_;
};
// -------------------------------------------------------------------

class CSSyn : public ::google_public::protobuf::Message {
 public:
  CSSyn();
  virtual ~CSSyn();

  CSSyn(const CSSyn& from);

  inline CSSyn& operator=(const CSSyn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSSyn& default_instance();

  void Swap(CSSyn* other);

  // implements Message ----------------------------------------------

  CSSyn* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSSyn& from);
  void MergeFrom(const CSSyn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // required string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // @@protoc_insertion_point(class_scope:connector_client.CSSyn)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* appid_;
  ::std::string* openid_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSSyn* default_instance_;
};
// -------------------------------------------------------------------

class CSSynAck : public ::google_public::protobuf::Message {
 public:
  CSSynAck();
  virtual ~CSSynAck();

  CSSynAck(const CSSynAck& from);

  inline CSSynAck& operator=(const CSSynAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSSynAck& default_instance();

  void Swap(CSSynAck* other);

  // implements Message ----------------------------------------------

  CSSynAck* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSSynAck& from);
  void MergeFrom(const CSSynAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string secretkey = 1;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretkeyFieldNumber = 1;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const char* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // @@protoc_insertion_point(class_scope:connector_client.CSSynAck)
 private:
  inline void set_has_secretkey();
  inline void clear_has_secretkey();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* secretkey_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSSynAck* default_instance_;
};
// -------------------------------------------------------------------

class CSAuth : public ::google_public::protobuf::Message {
 public:
  CSAuth();
  virtual ~CSAuth();

  CSAuth(const CSAuth& from);

  inline CSAuth& operator=(const CSAuth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSAuth& default_instance();

  void Swap(CSAuth* other);

  // implements Message ----------------------------------------------

  CSAuth* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSAuth& from);
  void MergeFrom(const CSAuth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:connector_client.CSAuth)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSAuth* default_instance_;
};
// -------------------------------------------------------------------

class CSPassport : public ::google_public::protobuf::Message {
 public:
  CSPassport();
  virtual ~CSPassport();

  CSPassport(const CSPassport& from);

  inline CSPassport& operator=(const CSPassport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSPassport& default_instance();

  void Swap(CSPassport* other);

  // implements Message ----------------------------------------------

  CSPassport* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSPassport& from);
  void MergeFrom(const CSPassport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 passport = 1;
  inline bool has_passport() const;
  inline void clear_passport();
  static const int kPassportFieldNumber = 1;
  inline ::google_public::protobuf::int64 passport() const;
  inline void set_passport(::google_public::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:connector_client.CSPassport)
 private:
  inline void set_has_passport();
  inline void clear_has_passport();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_public::protobuf::int64 passport_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSPassport* default_instance_;
};
// -------------------------------------------------------------------

class CSStart : public ::google_public::protobuf::Message {
 public:
  CSStart();
  virtual ~CSStart();

  CSStart(const CSStart& from);

  inline CSStart& operator=(const CSStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSStart& default_instance();

  void Swap(CSStart* other);

  // implements Message ----------------------------------------------

  CSStart* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSStart& from);
  void MergeFrom(const CSStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google_public::protobuf::int32 code() const;
  inline void set_code(::google_public::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:connector_client.CSStart)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::google_public::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSStart* default_instance_;
};
// -------------------------------------------------------------------

class CSError : public ::google_public::protobuf::Message {
 public:
  CSError();
  virtual ~CSError();

  CSError(const CSError& from);

  inline CSError& operator=(const CSError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSError& default_instance();

  void Swap(CSError* other);

  // implements Message ----------------------------------------------

  CSError* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSError& from);
  void MergeFrom(const CSError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google_public::protobuf::int32 code() const;
  inline void set_code(::google_public::protobuf::int32 value);

  // required string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:connector_client.CSError)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* desc_;
  ::google_public::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSError* default_instance_;
};
// -------------------------------------------------------------------

class CSBody : public ::google_public::protobuf::Message {
 public:
  CSBody();
  virtual ~CSBody();

  CSBody(const CSBody& from);

  inline CSBody& operator=(const CSBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSBody& default_instance();

  void Swap(CSBody* other);

  // implements Message ----------------------------------------------

  CSBody* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSBody& from);
  void MergeFrom(const CSBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .connector_client.CSSyn syn = 1;
  inline bool has_syn() const;
  inline void clear_syn();
  static const int kSynFieldNumber = 1;
  inline const ::connector_client::CSSyn& syn() const;
  inline ::connector_client::CSSyn* mutable_syn();
  inline ::connector_client::CSSyn* release_syn();
  inline void set_allocated_syn(::connector_client::CSSyn* syn);

  // optional .connector_client.CSSynAck ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::connector_client::CSSynAck& ack() const;
  inline ::connector_client::CSSynAck* mutable_ack();
  inline ::connector_client::CSSynAck* release_ack();
  inline void set_allocated_ack(::connector_client::CSSynAck* ack);

  // optional .connector_client.CSAuth auth = 3;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 3;
  inline const ::connector_client::CSAuth& auth() const;
  inline ::connector_client::CSAuth* mutable_auth();
  inline ::connector_client::CSAuth* release_auth();
  inline void set_allocated_auth(::connector_client::CSAuth* auth);

  // optional .connector_client.CSPassport passport = 4;
  inline bool has_passport() const;
  inline void clear_passport();
  static const int kPassportFieldNumber = 4;
  inline const ::connector_client::CSPassport& passport() const;
  inline ::connector_client::CSPassport* mutable_passport();
  inline ::connector_client::CSPassport* release_passport();
  inline void set_allocated_passport(::connector_client::CSPassport* passport);

  // optional .connector_client.CSStart start = 5;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 5;
  inline const ::connector_client::CSStart& start() const;
  inline ::connector_client::CSStart* mutable_start();
  inline ::connector_client::CSStart* release_start();
  inline void set_allocated_start(::connector_client::CSStart* start);

  // optional bytes data = 16;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 16;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .connector_client.CSError error = 100;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 100;
  inline const ::connector_client::CSError& error() const;
  inline ::connector_client::CSError* mutable_error();
  inline ::connector_client::CSError* release_error();
  inline void set_allocated_error(::connector_client::CSError* error);

  // @@protoc_insertion_point(class_scope:connector_client.CSBody)
 private:
  inline void set_has_syn();
  inline void clear_has_syn();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_passport();
  inline void clear_has_passport();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_error();
  inline void clear_has_error();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::connector_client::CSSyn* syn_;
  ::connector_client::CSSynAck* ack_;
  ::connector_client::CSAuth* auth_;
  ::connector_client::CSPassport* passport_;
  ::connector_client::CSStart* start_;
  ::std::string* data_;
  ::connector_client::CSError* error_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSBody* default_instance_;
};
// -------------------------------------------------------------------

class CSMsg : public ::google_public::protobuf::Message {
 public:
  CSMsg();
  virtual ~CSMsg();

  CSMsg(const CSMsg& from);

  inline CSMsg& operator=(const CSMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google_public::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google_public::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google_public::protobuf::Descriptor* descriptor();
  static const CSMsg& default_instance();

  void Swap(CSMsg* other);

  // implements Message ----------------------------------------------

  CSMsg* New() const;
  void CopyFrom(const ::google_public::protobuf::Message& from);
  void MergeFrom(const ::google_public::protobuf::Message& from);
  void CopyFrom(const CSMsg& from);
  void MergeFrom(const CSMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  ::google_public::protobuf::uint8* SerializeWithCachedSizesToArray(::google_public::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google_public::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .connector_client.CSHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::connector_client::CSHead& head() const;
  inline ::connector_client::CSHead* mutable_head();
  inline ::connector_client::CSHead* release_head();
  inline void set_allocated_head(::connector_client::CSHead* head);

  // required .connector_client.CSBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::connector_client::CSBody& body() const;
  inline ::connector_client::CSBody* mutable_body();
  inline ::connector_client::CSBody* release_body();
  inline void set_allocated_body(::connector_client::CSBody* body);

  // @@protoc_insertion_point(class_scope:connector_client.CSMsg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google_public::protobuf::UnknownFieldSet _unknown_fields_;

  ::connector_client::CSHead* head_;
  ::connector_client::CSBody* body_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CSMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// CSHead

// required int32 magic = 1 [default = 13124];
inline bool CSHead::has_magic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSHead::set_has_magic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSHead::clear_has_magic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSHead::clear_magic() {
  magic_ = 13124;
  clear_has_magic();
}
inline ::google_public::protobuf::int32 CSHead::magic() const {
  return magic_;
}
inline void CSHead::set_magic(::google_public::protobuf::int32 value) {
  set_has_magic();
  magic_ = value;
}

// required int64 sequence = 2;
inline bool CSHead::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSHead::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSHead::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSHead::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google_public::protobuf::int64 CSHead::sequence() const {
  return sequence_;
}
inline void CSHead::set_sequence(::google_public::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// required int32 bodyid = 3;
inline bool CSHead::has_bodyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSHead::set_has_bodyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSHead::clear_has_bodyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSHead::clear_bodyid() {
  bodyid_ = 0;
  clear_has_bodyid();
}
inline ::google_public::protobuf::int32 CSHead::bodyid() const {
  return bodyid_;
}
inline void CSHead::set_bodyid(::google_public::protobuf::int32 value) {
  set_has_bodyid();
  bodyid_ = value;
}

// -------------------------------------------------------------------

// CSSyn

// required string appid = 1;
inline bool CSSyn::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSyn::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSyn::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSyn::clear_appid() {
  if (appid_ != &::google_public::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& CSSyn::appid() const {
  return *appid_;
}
inline void CSSyn::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google_public::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void CSSyn::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google_public::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void CSSyn::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google_public::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSSyn::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google_public::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* CSSyn::release_appid() {
  clear_has_appid();
  if (appid_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSSyn::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google_public::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// required string openid = 2;
inline bool CSSyn::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSyn::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSyn::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSyn::clear_openid() {
  if (openid_ != &::google_public::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& CSSyn::openid() const {
  return *openid_;
}
inline void CSSyn::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google_public::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void CSSyn::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google_public::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void CSSyn::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google_public::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSSyn::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google_public::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* CSSyn::release_openid() {
  clear_has_openid();
  if (openid_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSSyn::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google_public::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSSynAck

// required string secretkey = 1;
inline bool CSSynAck::has_secretkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSynAck::set_has_secretkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSynAck::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSynAck::clear_secretkey() {
  if (secretkey_ != &::google_public::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& CSSynAck::secretkey() const {
  return *secretkey_;
}
inline void CSSynAck::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google_public::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSSynAck::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google_public::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSSynAck::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google_public::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSSynAck::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google_public::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* CSSynAck::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSSynAck::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google_public::protobuf::internal::kEmptyString) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSAuth

// required string token = 1;
inline bool CSAuth::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAuth::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAuth::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAuth::clear_token() {
  if (token_ != &::google_public::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CSAuth::token() const {
  return *token_;
}
inline void CSAuth::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google_public::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSAuth::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google_public::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSAuth::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google_public::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAuth::mutable_token() {
  set_has_token();
  if (token_ == &::google_public::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSAuth::release_token() {
  clear_has_token();
  if (token_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAuth::set_allocated_token(::std::string* token) {
  if (token_ != &::google_public::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSPassport

// optional int64 passport = 1;
inline bool CSPassport::has_passport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPassport::set_has_passport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPassport::clear_has_passport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPassport::clear_passport() {
  passport_ = GOOGLE_LONGLONG(0);
  clear_has_passport();
}
inline ::google_public::protobuf::int64 CSPassport::passport() const {
  return passport_;
}
inline void CSPassport::set_passport(::google_public::protobuf::int64 value) {
  set_has_passport();
  passport_ = value;
}

// -------------------------------------------------------------------

// CSStart

// optional int32 code = 1;
inline bool CSStart::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStart::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStart::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStart::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google_public::protobuf::int32 CSStart::code() const {
  return code_;
}
inline void CSStart::set_code(::google_public::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// CSError

// required int32 code = 1;
inline bool CSError::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSError::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSError::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSError::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google_public::protobuf::int32 CSError::code() const {
  return code_;
}
inline void CSError::set_code(::google_public::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required string desc = 2;
inline bool CSError::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSError::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSError::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSError::clear_desc() {
  if (desc_ != &::google_public::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& CSError::desc() const {
  return *desc_;
}
inline void CSError::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google_public::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CSError::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google_public::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CSError::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google_public::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSError::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google_public::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* CSError::release_desc() {
  clear_has_desc();
  if (desc_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSError::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google_public::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBody

// optional .connector_client.CSSyn syn = 1;
inline bool CSBody::has_syn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBody::set_has_syn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBody::clear_has_syn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBody::clear_syn() {
  if (syn_ != NULL) syn_->::connector_client::CSSyn::Clear();
  clear_has_syn();
}
inline const ::connector_client::CSSyn& CSBody::syn() const {
  return syn_ != NULL ? *syn_ : *default_instance_->syn_;
}
inline ::connector_client::CSSyn* CSBody::mutable_syn() {
  set_has_syn();
  if (syn_ == NULL) syn_ = new ::connector_client::CSSyn;
  return syn_;
}
inline ::connector_client::CSSyn* CSBody::release_syn() {
  clear_has_syn();
  ::connector_client::CSSyn* temp = syn_;
  syn_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_syn(::connector_client::CSSyn* syn) {
  delete syn_;
  syn_ = syn;
  if (syn) {
    set_has_syn();
  } else {
    clear_has_syn();
  }
}

// optional .connector_client.CSSynAck ack = 2;
inline bool CSBody::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBody::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBody::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBody::clear_ack() {
  if (ack_ != NULL) ack_->::connector_client::CSSynAck::Clear();
  clear_has_ack();
}
inline const ::connector_client::CSSynAck& CSBody::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::connector_client::CSSynAck* CSBody::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::connector_client::CSSynAck;
  return ack_;
}
inline ::connector_client::CSSynAck* CSBody::release_ack() {
  clear_has_ack();
  ::connector_client::CSSynAck* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_ack(::connector_client::CSSynAck* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .connector_client.CSAuth auth = 3;
inline bool CSBody::has_auth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBody::set_has_auth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBody::clear_has_auth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBody::clear_auth() {
  if (auth_ != NULL) auth_->::connector_client::CSAuth::Clear();
  clear_has_auth();
}
inline const ::connector_client::CSAuth& CSBody::auth() const {
  return auth_ != NULL ? *auth_ : *default_instance_->auth_;
}
inline ::connector_client::CSAuth* CSBody::mutable_auth() {
  set_has_auth();
  if (auth_ == NULL) auth_ = new ::connector_client::CSAuth;
  return auth_;
}
inline ::connector_client::CSAuth* CSBody::release_auth() {
  clear_has_auth();
  ::connector_client::CSAuth* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_auth(::connector_client::CSAuth* auth) {
  delete auth_;
  auth_ = auth;
  if (auth) {
    set_has_auth();
  } else {
    clear_has_auth();
  }
}

// optional .connector_client.CSPassport passport = 4;
inline bool CSBody::has_passport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBody::set_has_passport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBody::clear_has_passport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBody::clear_passport() {
  if (passport_ != NULL) passport_->::connector_client::CSPassport::Clear();
  clear_has_passport();
}
inline const ::connector_client::CSPassport& CSBody::passport() const {
  return passport_ != NULL ? *passport_ : *default_instance_->passport_;
}
inline ::connector_client::CSPassport* CSBody::mutable_passport() {
  set_has_passport();
  if (passport_ == NULL) passport_ = new ::connector_client::CSPassport;
  return passport_;
}
inline ::connector_client::CSPassport* CSBody::release_passport() {
  clear_has_passport();
  ::connector_client::CSPassport* temp = passport_;
  passport_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_passport(::connector_client::CSPassport* passport) {
  delete passport_;
  passport_ = passport;
  if (passport) {
    set_has_passport();
  } else {
    clear_has_passport();
  }
}

// optional .connector_client.CSStart start = 5;
inline bool CSBody::has_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBody::set_has_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBody::clear_has_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBody::clear_start() {
  if (start_ != NULL) start_->::connector_client::CSStart::Clear();
  clear_has_start();
}
inline const ::connector_client::CSStart& CSBody::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::connector_client::CSStart* CSBody::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::connector_client::CSStart;
  return start_;
}
inline ::connector_client::CSStart* CSBody::release_start() {
  clear_has_start();
  ::connector_client::CSStart* temp = start_;
  start_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_start(::connector_client::CSStart* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional bytes data = 16;
inline bool CSBody::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSBody::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSBody::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSBody::clear_data() {
  if (data_ != &::google_public::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CSBody::data() const {
  return *data_;
}
inline void CSBody::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google_public::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CSBody::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google_public::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CSBody::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google_public::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBody::mutable_data() {
  set_has_data();
  if (data_ == &::google_public::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CSBody::release_data() {
  clear_has_data();
  if (data_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBody::set_allocated_data(::std::string* data) {
  if (data_ != &::google_public::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// optional .connector_client.CSError error = 100;
inline bool CSBody::has_error() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSBody::set_has_error() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSBody::clear_has_error() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSBody::clear_error() {
  if (error_ != NULL) error_->::connector_client::CSError::Clear();
  clear_has_error();
}
inline const ::connector_client::CSError& CSBody::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::connector_client::CSError* CSBody::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::connector_client::CSError;
  return error_;
}
inline ::connector_client::CSError* CSBody::release_error() {
  clear_has_error();
  ::connector_client::CSError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CSBody::set_allocated_error(::connector_client::CSError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// CSMsg

// required .connector_client.CSHead head = 1;
inline bool CSMsg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsg::clear_head() {
  if (head_ != NULL) head_->::connector_client::CSHead::Clear();
  clear_has_head();
}
inline const ::connector_client::CSHead& CSMsg::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::connector_client::CSHead* CSMsg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::connector_client::CSHead;
  return head_;
}
inline ::connector_client::CSHead* CSMsg::release_head() {
  clear_has_head();
  ::connector_client::CSHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_head(::connector_client::CSHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .connector_client.CSBody body = 2;
inline bool CSMsg::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsg::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsg::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsg::clear_body() {
  if (body_ != NULL) body_->::connector_client::CSBody::Clear();
  clear_has_body();
}
inline const ::connector_client::CSBody& CSMsg::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::connector_client::CSBody* CSMsg::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::connector_client::CSBody;
  return body_;
}
inline ::connector_client::CSBody* CSMsg::release_body() {
  clear_has_body();
  ::connector_client::CSBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_body(::connector_client::CSBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace connector_client

#ifndef SWIG
namespace google_public {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::connector_client::ConnectorMagic>() {
  return ::connector_client::ConnectorMagic_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::connector_client::BodyCmdId>() {
  return ::connector_client::BodyCmdId_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eproto__INCLUDED
